External Client ‚Üí NodePort (optional) ‚Üí Service port ‚Üí targetPort ‚Üí containerPort ‚Üí App

How Deployments behave

Pods in a Deployment are anonymous and interchangeable.
If a pod crashes or the node fails:

Kubernetes deletes the old pod and creates a new one with a different name (e.g., mysql-abc123 ‚Üí mysql-xyz789).


If you attach a PVC manually:

You can bind it to the Deployment, but all pods share the same PVC (bad for scaling).
If you try to create multiple PVCs for multiple pods, you must manage them manually because Deployment doesn‚Äôt know which PVC belongs to which pod.



Result:

Pod identity changes ‚Üí DNS changes ‚Üí replication breaks.
PVC binding is not guaranteed per pod ‚Üí risk of wrong data attached.


How StatefulSets behave

Pods have stable names (mysql-0, mysql-1).
Each pod gets its own PVC automatically via volumeClaimTemplates.
If mysql-0 crashes:

Kubernetes recreates mysql-0 (same name, same PVC).


DNS stays predictable: mysql-0.mysql.default.svc.cluster.local.

Result:

Identity is stable ‚Üí replication works.
Storage binding is automatic and correct ‚Üí data integrity preserved.

ARCHITECTURE FLOW OF KUBERNETES

‚úÖ Example Scenario: Deploying a Pod via Deployment

1. kubectl (Client) ‚Üí API Server

You run:
Shellkubectl apply -f deployment.yamlShow more lines

Role: kubectl sends the desired state (Deployment manifest) to the API Server via REST.


2. API Server ‚Üí etcd

API Server validates the request and stores the Deployment object in etcd (the cluster‚Äôs source of truth).
Role: API Server = front door for all requests; etcd = persistent store for cluster state.


3. Controller Manager (Deployment Controller)

Watches etcd for new Deployment objects.
Sees:
Desired: 3 replicas
Actual: 0


Creates ReplicaSet, which then creates 3 Pod objects (state = Pending).
Role: Controllers reconcile desired vs actual state.


4. Scheduler

Watches for Pending Pods (no Node assigned).
Picks a suitable Node for each Pod based on:

Resource availability (CPU, memory)
Node affinity/taints
Scheduling policies


Updates Pod spec with nodeName.
Role: Decides where Pods run.


5. Kubelet (on each Node)

Watches API Server for Pods assigned to its Node.
Pulls container image from registry.
Creates containers via Container Runtime (e.g., containerd).
Reports Pod status back to API Server.
Role: Ensures containers run on the Node.


6. Container Runtime

Actually runs the containers inside the Pod.
Handles networking and storage setup.
Role: Executes containers.


7. kube-proxy

Updates iptables or IPVS rules for Services.
Ensures traffic can reach Pods via ClusterIP, NodePort, etc.
Role: Networking for Services.


8. Continuous Sync

Controller Manager keeps watching:

If a Pod crashes ‚Üí creates a new Pod.
Scheduler assigns again.


Role: Self-healing loop.


üîç Visual Flow Summary:
kubectl ‚Üí API Server ‚Üí etcd ‚Üí Controller ‚Üí Scheduler ‚Üí Kubelet ‚Üí Container Runtime ‚Üí kube-proxy


‚úÖ This is the core Kubernetes control loop:
Declarative desired state ‚Üí stored in etcd ‚Üí controllers reconcile ‚Üí scheduler places ‚Üí kubelet runs ‚Üí runtime executes ‚Üí networking via kube-proxy.

Kubernetes or K8s

A container orchestration technology that manages and deploys thousands of containers in a cluster.

kubectl is the command line utility to interact with kubernetes cluster

COMMANDS:

kubectl run <name> -> run an application in the cluster

kubectl cluter-info -> to get info about the cluster

kubectl get nodes -> to list all of the nodes that are parts of the cluster

kubernetes run nginx --image nginx -> this command will create a container inside a pod named nginx, we have to specify image name with the help of --image flag

kubectl get pods -> helps us see the list of pods in our cluster

kubectl describe pod nginx -> to show detailed information about a specified pod (any pod name in place of nginx)

kubectl get pods -o wide -> show additional information such as the node in which the pod is running

kubectl create deployment nginx --image=nginx -> To create a deployment


Using Manifest-file/YAML file to create pods, services, deployments etc
kubectl create -f (<name>.yml) -> to create pods,services,etc from manifest file (yml file)

kubectl delete pod <pod_name> -> to delete a pod

kubectl edit replicaset <replicaset_name> : to edit an already running replicaset object

kubectl delete replicaset <replicaset_name> : to delete a replicaset

kubectl get replicaSets or replicaset -> to see the current running replicaset
kubectl scale replicaset <replicaset_name> --replicas=3 (or any number) -> to scale up or down the replicas to specified replicas count

kubectl get all -> to get the list of all kubernetes objects (pods, services, replicaset, deployments, etc)

kubectl delete all --all -> To delete all the resources in the current namespace (i.e to remove all the kubernetes objects)

kubectl get deployments -> to list all the deployment objects in kubernetes

kubectl describe deployment <deployment_name> : To show info about a deployment such as images used etc...

kubectl delete deployment <deployment_name> : To delete a deployment

# Rollout and Rollback in deployment

STEP BY STEP
Step 1: CREATE
kubectl create (or apply) -f <deployment_file> -> To create a deployment object in kubernetes

Step 2: UPDATE
kubectl set image deployment/myapp-deployment nginx=nginx:1.9.1

Step 3: Check STATUS and HISTORY
kubectl rollout status deployment/myapp-deployment
kubectl rollout history deployment/myapp-deployment

Step 4: ROLLBACK To Previous Version
kubectl rollout undo deployment/myapp-deployment

kubectl create -f <yaml_manifest> --record=True : It helps in tracking the history of changes to a Deployment.

kubectl set image deployment/<deployment_name> <container_name>=<new_image_value> - To update the image of an container in order to upgrade our application
(ALTERNATIVE: directly change the manifest file)


NETWORKING IN KUBERNETES

There are 3 main type of IPs in kubernetes network:

1. Node IP
2. Pod IP
3. Cluster IP

SERVICES IN KUBERNETES

Service in kubernetes is a object whose usecase is to listen to a port in a node and forward the request on that port to a port on the pod running the web application. This type of service is known as the node port service. 

Types of services:
1) NodePort service: service makes an internal pod accessible to the port on the node 
2) ClusterIP: In this, the service creates an internal IP inside a cluster to enable connection between the services such as frontend server with backend server
3) LoadBalancer: 

kubectl port-forward svc/<service_name> <required_port>:<service_port>